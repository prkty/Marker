# AI 활용 기록 (AI-Notes)

이 문서는 'Marker' 프로젝트를 개발하면서 사용한 인공지능(AI) 도구와 그 활용 방식을 기록하기 위해 작성되었습니다. 프로젝트를 시작하기에 앞서, 각 AI의 코딩에서의 특징을 경험과 정보를 종합하여 파악하고, 개발 단계와 목적에 따라 각 도구를 적절하게 사용하고자 했습니다.

## 1. 사용한 AI/도구

-   **Gemini Code Assist (Google)**
    -   **주요 역할**: 프로젝트의 메인 개발 파트너.
    -   **선택 이유**: 대화의 맥락을 기억하고 프로젝트 파일과 직접 상호작용하는 에이전트 모드를 지원하며, 방대한 양의 컨텍스트를 처리할 수 있는 높은 퀄리티를 제공하기 때문에 주력 도구로 사용했습니다. 주요 기능 구현, 코드 리팩토링, 심층적인 버그 트러블슈팅, 테스트 코드 작성, 문서 생성 등 프로젝트 전반에 걸쳐 핵심적인 역할을 수행했습니다.

-   **ChatGPT (OpenAI)**
    -   **주요 역할**: 이중 검증 및 대안 탐색.
    -   **활용 방식**: 전체적으로 뛰어난 모델이라고 판단하여, Gemini가 생성한 코드나 해결책에 할루시네이션 증상이 없는지 이중으로 검증하는 데 사용했습니다. 또한, 트러블슈팅 과정에서 특정 문제에 대한 대체 코드나 다른 라이브러리/패키지에 대한 조언을 얻기 위해 활용했습니다. 캐싱 규칙과 조건을 설계할 때도 도움을 받았습니다.

-   **Claude (Anthropic)**
    -   **주요 역할**: 코드 품질 및 구조 검증.
    -   **활용 방식**: 코드 생성 능력이 뛰어나다고 판단하여, 생성된 코드의 품질과 구조적 완성도를 검증하는 데 주로 사용했습니다. 특히, 코드의 작동 방식에 따라 테스트 케이스가 잘 작성되었는지, 그리고 향후 유지보수성이 떨어지지는 않는지 등을 검토하고 필요에 따라 코드 리팩토링을 요청하는 데 활용했습니다.

## 2. 주요 프롬프트 또는 활용 방식 (핵심 4가지)

#### 1. 기능 구현 및 리팩토링 요청

-   **활용 방식**: 특정 기능 구현을 위한 전체적인 코드 생성을 요청하고, 이후 단계적으로 리팩토링을 진행했습니다.
-   **주요 프롬프트**:
    -   `"JWT와 Spring Security를 이용한 인증/인가 시스템을 구현해줘."`
    -   `"Spring Cache를 이용해서 자주 조회되는 데이터 캐싱을 구현해보자."`
-   **결과**: 이 프롬프트를 통해 `User` 엔티티, `SecurityConfig`, `JwtTokenProvider`, `AuthService` 등 인증/인가 시스템의 전체적인 골격을 생성했습니다. 또한, 캐싱 기능 구현을 위한 `@Cacheable`, `@CachePut`, `@CacheEvict` 어노테이션 적용 및 서비스 로직 구조 변경의 기반을 마련했습니다.

#### 2. 심층적인 버그 트러블슈팅

-   **활용 방식**: 테스트 실패 로그나 애플리케이션 실행 시 발생하는 오류 메시지 전체를 그대로 제공하고, 원인 분석과 해결책을 요청했습니다.
-   **주요 프롬프트**:
    -   `"BookmarkServiceTest에서 대규모 테스트 실패가 발생했어. [오류 로그 전체 붙여넣기]"`
    -   `"캐싱이 동작하지 않아. 동일한 ID로 조회해도 계속 SELECT 쿼리가 실행돼. [서버 로그 붙여넣기]"`
-   **결과**: 캐싱이 동작하지 않았던 복합적인 원인(AOP 자기 호출, 인증 필터의 DB 조회, `@EnableCaching` 누락 등)을 단계적으로 분석하고 해결하는 데 결정적인 도움을 받았습니다. 또한, 단위 테스트 실패의 근본 원인(`@Spy`와 `self` 필드 문제)을 파악하고 올바른 테스트 코드로 수정할 수 있었습니다.

#### 3. 테스트 코드 생성 및 개선

-   **활용 방식**: 새로 구현한 기능에 대한 테스트 코드 생성을 요청하거나, 기존 테스트 코드의 문제점을 해결하기 위한 리팩토링을 요청했습니다.
-   **주요 프롬프트**:
    -   `"캐싱 기능이 의도대로 동작하는지 검증하는 테스트 코드를 작성해줘."`
    -   `"단위 테스트에서 @SpyBean이 deprecated 되었다는데, 어떻게 수정해야 해?"`
-   **결과**: `@SpyBean`을 활용한 캐싱 통합 테스트 클래스(`BookmarkServiceCachingTest`)의 전체 구조를 생성했습니다. 또한, `@Spy`와 `@InjectMocks`의 충돌로 인해 발생했던 단위 테스트(`BookmarkServiceTest`)의 오류를 해결하고, 최종적으로 안정적인 테스트 코드를 완성했습니다.

#### 4. 문서 자동 생성 (README, 커밋 메시지)

-   **활용 방식**: 프로젝트의 특정 기능이나 변경 사항에 대한 설명을 요청하고, 이를 바탕으로 `README.md`나 Git 커밋 메시지를 작성하도록 했습니다.
-   **주요 프롬프트**:
    -   `"지금까지의 모든 변경 사항을 요약해서 커밋 메시지를 작성해줘."`
    -   `"리드미에 우리가 구현한 CI에 대해서 어떻게 작성할 것 같아?"`
-   **결과**: 프로젝트의 주요 설계 이유, CI 환경 구축, 캐싱 전략 등 복잡한 내용을 체계적으로 정리한 `README.md` 문서를 작성했습니다. 또한, 각 기능 구현 단계별로 의미 있는 커밋 메시지를 생성하여 프로젝트의 변경 이력을 명확하게 관리할 수 있었습니다.

## 3. 생성 코드가 반영된 파일 또는 영역

-   **인증/인가**: `com.example.marker.security` 패키지 전체, `AuthService`, `AuthController`, `User` 엔티티
-   **캐싱**: `BookmarkService`의 캐싱 관련 어노테이션 및 내부 호출 구조, `BookmarkServiceCachingTest`
-   **테스트**: `BookmarkServiceTest`의 대규모 리팩토링
-   **예외 처리**: `GlobalExceptionHandler` 및 커스텀 예외 클래스 (`UnauthorizedBookmarkAccessException` 등)
-   **CI**: `.github/workflows/build-and-test.yml` 파일
-   **문서**: `README.md`, `api-docs.md`

## 4. AI 생성물에 대해 직접 수정·검증한 부분 요약

-   **버전 호환성 검증**: AI가 제안한 라이브러리 버전(예: `springdoc-openapi`)이 현재 프로젝트의 Spring Boot 버전과 호환되지 않는 경우가 있어, 안정적인 버전으로 직접 수정했습니다.
-   **실행 방식의 차이 인지**: AI가 제안한 코드가 정상임에도 불구하고 문제가 해결되지 않았을 때, 원인이 코드 자체가 아닌 애플리케이션 실행 방식(`bootRun` vs `java -jar`)의 차이임을 직접 파악하고 해결했습니다.
-   **보안 취약점 발견 및 수정**: AI가 초기에 제안한 캐싱 로직(`key = "#bookmarkId"`)에 다른 사용자의 데이터가 조회되는 심각한 보안 취약점이 있음을 직접 발견하고, 캐시 키에 사용자 ID를 포함하도록 수정하여 문제를 해결했습니다.
-   **테스트 코드 리팩토링**: AI가 제안한 테스트 코드(`@Spy`, `@InjectMocks` 사용 등)가 복잡성을 증가시키는 경우, 최종적으로는 더 단순하고 표준적인 단위 테스트 원칙에 맞게 직접 코드를 재구성하고 안정화시켰습니다.
-   **API 문서(Swagger) 사용성 개선**: AI가 생성한 API 문서에서 실패 응답의 예시 값이 불필요하게 공간을 차지하는 점을 지적하고, `@Content` 어노테이션을 활용하여 문서를 더 깔끔하게 개선했습니다. 또한, 누락된 인증/인가 관련 에러 코드를 명시적으로 추가하도록 요청하여 문서의 완성도를 높였습니다.
-   **인증 필터 성능 문제 해결**: 캐싱 문제 트러블슈팅 중, AI가 제시한 해결책 외에 서버 로그를 직접 분석하여 인증 필터 단계에서 불필요한 DB 조회가 발생함을 발견했습니다. 이 발견을 바탕으로 AI와 함께 필터 로직을 리팩토링하여 시스템 전반의 성능을 개선했습니다.
